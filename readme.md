# Задача

Необходимо реализовать класс контроллера поддерживающий идемпотентность и защиту от гонки процессов.
На вход подаются два необязательных параметра: ключ идемпотентности и одно натуральное число.
На выходе контроллер должен вернуть сумму поданных на вход натуральных чисел когда-либо.

Хранилищем данных для получения суммы натуральных чисел должен быть Mysql, для работы с идемпотентностью
и защитой от гонки процессов можно использовать как Redis, так и Mysql.
Время жизни Redis ключей должно быть ограничено.

Нельзя подключать готовые библиотеки, реализующие функционал идемпотентности или защиты от гонки процессов,
если таковые имеются. Нельзя использовать процедуры в MySql.

Контроллер работает под любым веб-сервером запущенным под несколько инстансов.

Код должен быть покрыт тестами.

# Техническое решение

Суть ключа идемпотентности в том, что запрос на изменнеие данных с одним уникальным ключем выполняется один раз.
Соответсвенно первым делом, проверяем есть ли уже указанный ключ в быстром хранилище или нет. В качестве быстрого хранилища используем Redis.

Если ключ отсутствует, то мы сразу же сохраняем ключ в Redis и помечаем как 'In Process', это предотвратит обработку такого же запроса другим параллельным запросом. Далее выполняем БЛ и в случае успеха, перезаписываем помеченный ключ значением содержащим сумму за все время. Гарантированность того, что за время проверки существования ключа и его установки, не произойдет коллизий, отвечает транзакция в Redis.

Если ключ уже есть и он помечен как 'In Process', то мы возвращаем данный статус клиенту, что операция в процессе и надо подождать.

Если ключ уже есть и он не помечен как 'In Process', то мы можем вернуть закешированный результат работы предыдущего запроса и предотвратить коллизии.

Для хранения результатов суммы по условиям задачи используем Mysql с движком InnoDb Т.к. не оговаривалась структура БД то мы используем минимально рабочий вариант, когда имеем одну таблицу и для хранения суммы используем одну запись с id=1.

Благодоря такой структуре БД мы можем в рамках одного запроса `INSERT ON DUPLICATE KEY UPDATE` как инициализировать таблицу если она пустая, так и обновить сумму если она уже имеется.

После сохранения суммы в БД мы делаем отдельный селект на чтение текущей суммы и т.к. по условиям задачи не сказано что мы должны точно соблюдать хронологию запросов, то с момента обновления суммы и чтения, сумма еще раз могла измениться другим паралельным запросом. Мы допускаем такой вариант и поэтому чтение и обновление суммы не выносим в рамки одной транзакции.

Так же в рамках этого решения не рассматриваются варианты, когда запрос не смог выполниться успешно, т.е. у нас остался ключ с пометкой 'In Process'. По сути, этот ключ удалится из Redis по таймауту, и клиент сможет повторить свой запрос, тут нужна настройка таймаутов.

# Запуск

- Установить docker и docker-compose
- Скопировать `.env.dist` в `.env`
- Настроить `.env`
- Запустить контейнеры `docker-compose up -d`
- Запустить `docker-compose run phpcomposer composer install`
- Настроить DNS `sum.local` на машину с докером
- Открыть страницу `http://sum.local/test-sum-action?ikey=test1&number=5`
  где параметры запроса ikey - ключ идемпотентности, number - число для суммирования
  результат: новая сумма, либо закешированная сумма для этого `ikey`

# Тестирование

Перейти в контейнер `docker-compose exec phpfpm_8_1 sh`

Запустить `./vendor/bin/phpunit` - для всех тестов

Запустить `./vendor/bin/phpunit --testsuite Unit` - для юнит тестов

Запустить `./vendor/bin/phpunit --testsuite Functional` - для функциональных тестов

Выйти из контейнера `exit`

Остановить контейнеры `docker-compose down`